---
layout: archive
lang: kr
ref: rplus1_task_programming_01
read_time: true
share: true
author_profile: false
permalink: /docs/kr/software/rplus1/task/programming_01/
sidebar:
  title: 로보플러스 태스크 1.0
  nav: "rplustask1"
---

<style>body {counter-reset: h1 2 !important;}</style>

# [프로그래밍](#프로그래밍)

## [편집](#편집)
RoboPlus Task에서 편집할 때 사용하는 방법들입니다.

### [여러줄 선택](#여러줄-선택)
RoboPlus Task는 프로그램 코드에서 잘라내기, 복사, 삭제, 주석처리 등의 편집을 위해 여러줄 선택 기능을 지원합니다.

프로그램 코드에서 여러줄을 선택하는 방법은 다음과 같습니다.

- 컨트롤(Ctrl) 키를 누른 상태에서 마우스 클릭으로 여러줄 선택

  ![여러줄 선택][ctrl-select]

- 쉬프트(Shift) 키를 누른 상태에서 선택하려는 첫 번째 명령줄을 마우스 클릭 후, 마지막 명령줄을 클릭하여 여러줄 선택
- 마우스로 클릭 후 드래그하여 여러줄 선택하여도 같은 결과를 얻을 수 있습니다.

  ![여러줄 선택][sft-select]

- 프로그램 코드 전체를 선택하려면 마우스 오른쪽 버튼을 눌러 '모두 선택' 명령을 실행합니다. 단축키는, 컨트롤(Ctrl) + A 입니다.

  ![전체 선택][select-all]

### [줄 삽입](#줄-삽입)
프로그램 코드에 빈 줄을 삽입하는 방법은 다음과 같습니다.

- 삽입하고자 하는 명령줄 위를 선택한 후 `스페이스바`(SpaceBar)를 입력합니다.
- 삽입하고자 하는 명령줄 위를 선택한 후 마우스 오른쪽 버튼을 눌러 '줄 삽입' 명령을 실행합니다.

  ![줄 삽입][insert-line]

### [줄 지우기](#줄-지우기)
하나의 줄, 혹은 여러 줄을 선택하여 지울 수 있습니다.

프로그램 코드에서 줄을 지우는 방법은 다음과 같습니다.

- 지우고자 하는 명령줄을 선택한 후 마우스 오른쪽 버튼을 눌러 '줄 내용 지우기' 명령을 실행합니다. 선택된 명령줄의 내용만 지워지고 명령줄은 그대로 남아있게 됩니다. 단축키는 백스페이스키(BackSpace, ←)입니다.

  ![줄 지우기][delete_backspace]

- 지우고자 하는 명령줄을 선택한 후 마우스 오른쪽 버튼을 눌러 '줄 지우기' 명령을 실행합니다. 선택된 명령줄과 내용이 모두 삭제되며, 아래줄 내용이 위로 당겨집니다. 단축키는 삭제키(Delete)입니다.

  ![줄 지우기][delete_delete]

### [줄 활성/비활성](#줄-활성비활성)
프로그램 코드에서 명령줄을 활성, 비활성시키는 방법은 다음과 같습니다.

- 활성, 혹은 비활성하고자 하는 명령줄을 선택한 후  마우스 오른쪽 버튼을 눌러 '줄 활성/비활성' 명령을 실행합니다.
- 활성, 혹은 비활성하고자 하는 명령줄을 선택한 후  컨트롤(Ctrl) + E 를 입력합니다.

  ![활성/비활성][activate]

- 활성화 되어있는 줄에서 이 명령을 실행하면 비활성 상태로 바뀌며, 비활성 상태에 있는 줄에서 이 명령을 실행하면 활성화 상태로 바뀌게 됩니다.
- 주로 프로그램 작성 중 테스트를 위해 잠시 명령을 실행하지 않도록 하는 등의 목적으로 많이 사용됩니다.

### [복사/잘라내기/붙여넣기](#복사잘라내기붙여넣기)

#### 복사하기

- 하나의 줄을 선택하거나, 여러줄을 선택한 후 마우스 오른쪽 버튼을 눌러 복사 명령을 실행합니다. 
- 복사하기를 실행한 줄은 그대로 남아있으며, 그 내용은 임시 저장소에 저장됩니다. 
- 복사하기 명령을 실행하는 순간, 기존에 임시 저장소에 저장되어 있던 내용은 삭제됩니다. 
- 단축키는 `컨트롤(Ctrl)` + `C` 입니다.

![복사하기][copy]

#### 잘라내기

- 하나의 줄을 선택하거나, 여러줄을 선택한 후 마우스 오른쪽 버튼을 눌러 잘라내기 명령을 실행합니다. 
- 잘라내기를 실행한 줄은 지워지며, 그 내용은 임시 저장소에 저장됩니다. 
- 잘라내기 명령을 실행하는 순간, 기존에 임시 저장소에 저장되어 있던 내용은 삭제됩니다. 
- 단축키는 `컨트롤(Ctrl)` + `X` 입니다.

![잘라내기][cut]

#### 붙여넣기

- 임시 저장소에 데이터가 저장되어 있는 경우 실행할 수 있습니다. 
- 붙여넣기를 실행 할 명령줄을 선택한 후 마우스 오른쪽 버튼을 눌러 붙여넣기 명령을 실행합니다. 
- 붙여넣기를 하여도 임시 저장소의 내용은 그대로 남아있으며, 따라서 같은 내용을 여러번 붙여넣을 수 있습니다. 
- 만약 빈 명령줄이 아닌, 기존에 선택된 내용 위에 붙여넣기를 하면 덮어쓰기가 됩니다. 
- 단축키는 `컨트롤(Ctrl)` + `V` 입니다.

![붙여넣기][paste]

### [이름찾기](#이름찾기)
프로그램 코드에서 사용한 요소의 찾기 기능을 지원합니다.

1. 편집 메뉴에서 이름 찾기 명령을 실행합니다. 단축키는 컨트롤(Ctrl) + F 입니다.

  ![이름찾기][search_name]

2. 찾고자 하는 내용을 입력 후 '다음 찾기' 버튼을 누릅니다.

  ![다음 찾기][search_next]

## [명렁어](#명령어)

### [프로그램 시작](#프로그램-시작)
프로그램 시작은 말 그대로 제일 먼저 실행되는 프로그램의 시작 지점입니다. 줄 번호와 상관 없이 무조건 프로그램 시작부터 명령이 실행됩니다. C언어의 main()함수와 같은 개념입니다.

#### 사용법

- 프로그램 시작 명령은 줄 번호와 상관 없이 실행됩니다.
- 한 프로그램에 두 개 이상의 프로그램 시작이 있을 수 없습니다.
- 명령 묶음 구간이 반드시 필요합니다.
- 프로그램 시작 명령 구간의 끝을 만나면 프로그램이 종료됩니다.

#### 예제

다음과 같이 프로그램 시작 명령을 기본으로 프로그래밍을 시작합니다.
![프로그램 시작][main]

### [프로그램 강제종료](#프로그램-강제종료)
프로그램 수행 중에 이 문장을 만나면 그대로 프로그램이 종료됩니다. 프로그램이 종료되는 경우는 다음과 같습니다.

1. 프로그램 시작의 구간을 다 수행한 경우 (자연 종료)
  
    ![자연종료][end01]

2. 프로그램 강제 종료를 만났을 경우 (강제 종료)
  
    ![강제종료][end02]

#### 사용법

프로그램을 끝내고 싶은 지점에 만듭니다.

#### 예제

포트 3의 터치센서가 눌렸을 때, 프로그램을 종료하는 예제입니다.

![종료예제][end_example]

### [구간 시작/끝](#구간-시작끝)
구간이란 여러 개의 명령문을 묶어놓은 것을 의미합니다. 구간 시작부터 끝까지 같은 명령문에 영향 받습니다. C언어의 '{', '}'와 같은 개념입니다.

#### 사용법

구간의 시작과 끝은 항상 짝이 맞아야 합니다. RoboPlus Task는 자동으로 구간별로 들여쓰기를 하여 짝이 맞는지 여부를 알려줍니다. 구간의 시작/끝 기호의 줄이 맞지 않는경우, 누락된 구간을 찾아서 적절히 수정해야 합니다.

![구간][section]

구간은 반드시 소유하는 명령이 있어야 합니다. 즉, 단독으로 사용할 수 없습니다.
구간 시작/끝을 반드시 가져야 할 명령은 다음과 같습니다.
- 프로그램 시작
- 만약  / 아니면 만약 / 아니면
- 무조건 반복
- 조건 반복
- 횟수 반복
- 콜백 함수
- 함수

만약에 실행문이 한줄일 경우에는 구간기호가 생략 될 수 있다.

![생략][omitted]

#### 예제

프로그램 시작 명령과 무조건 반복 명령에 구간의 시작과 끝이 설정되어 있는 예제입니다.

![구간예제][section_example]

### [주석/메모](#주석메모)
프로그램 코드 내에 주석이나 메모를 삽입할 수 있습니다. 주석이나 메모를 적절히 사용하면, 나중에 코드를 다시 해석할 때 매우 유용합니다. 잊기 쉬운 내용이나, 중요한 내용을 표시할 때 주로 사용합니다. 주석은  프로그램 실행에 아무런 영향을 주지 않습니다. C언어의 한 줄 주석처리 기호인 '//'와 같은 개념입니다. (C언어의 여러 줄 주석 처리 기호인 '/*', '*/'는 지원하지 않습니다.)

#### 사용법

- 주석이나 메모를 삽입하고 싶은 줄에서 명령을 실행합니다.
- // 기호가 삽입되면 마우스로 더블클릭하거나 키보드의 엔터(Enter)를 입력한 후, 원하는 내용을 입력 할 수 있습니다.
- 내용 입력 도중 ESC 키를 입력하면 작성 중에 있던 내용이 취소되고, 입력 전 내용으로 복구 됩니다.
- 내용 입력을 완료하려면, 키보드의 엔터(Enter)를 입력해야 합니다.

#### 예제

화면에 10을 출력 후 줄을 바꾸는 예제입니다. 아래와 같이 설명이나 메모를 프로그램에 삽입할 수 있습니다.

![주석][comment]

### [계산](#계산)
계산은 두 값을 연산하여 결과를 내는 명령어입니다. 의미는 다음과 같습니다.

![계산][math]

계산 명령어에서 사용할 수 있는 연산자는 다음과 같습니다.
- 사칙 연산 (음수 연산을 지원합니다.)
    - 덧셈(+): 두 값을 더합니다.
    - 뺄셈(-): 앞에서 뒤의 값을 뺍니다.
    - 곱셈(*): 두 값을 곱합니다.
    - 나눗셈(/): 앞에서 뒤의 값을 나눕니다. (나머지는 무시되어 사라지고 몫만 결과로 나옵니다.)
- 비트(bit) 연산 (2진수 연산을 의미합니다.)
    - AND(\&): 두 비트를 AND연산 합니다.
    - OR(\|): 두 비트를 OR연산 합니다.

#### 사용법

연산자를 마우스로 더블 클릭하거나 키보드의 ENTER키를 누르면 연산자 종류를 선택할 수 있습니다.

![연산자][select_operator]

명령 수행에 필요한 3개의 파라미터(결과, 연산1, 연산2)를 적절히 선택합니다.

![파라미터 선택][select_parameter]

#### 예제

10과 20을 더해서 화면출력하는 예제입니다.

![연산예제][math_example]

### [로드](#로드)
로드(Load)의 사전적 의미는 적재하다라는 뜻입니다. 즉, 로드는 값을 옮기는 명령을 수행합니다.

![로드][load]

로드는 다음과 같은 의미로 사용됩니다.
- 장치의 기능을 실행한다.
- 값을 옮긴다.

#### 사용법

명령 수행에 필요한 2개의 파라미터(대상, 원본)를 적절히 선택합니다.

![파라미터 선택][select_load]

#### 예제

장치의 기능 실행 용도로 사용된 경우 (타이머를 약 1초로 설정합니다.)

![예제01][load_example01]

값을 옮기는 용도로 사용된 경우 (변수에 5를 넣습니다.)

![예제02][load_example02]

### [레이블/점프](#레이블점프)
레이블과 점프는 프로그램 분기를 위해 사용됩니다. 프로그램 분기란, 프로그램 수행 순서를 바꾸는 것입니다. 점프는 프로그램 분기를 실행하고, 레이블은 분기할 위치를 지정합니다. C언어의 label/goto와 같은 개념입니다.

![레이블][label_jump]

#### 사용법

- 레이블 이름은 다음의 규칙을 지켜야 합니다.
  - 레이블 이름은 중복될 수 없습니다.
  - 레이블은 프로그램 시작 구문, 혹은 함수 구문 내부에 존재해야 합니다.
  - 다른 함수의 레이블로 점프할 수 없습니다.
  - 레이블 이름은 띄어쓰기와 특수 기호(!, @, #, $등)를 사용할 수 없습니다.
  - 레이블 이름의 시작은 숫자를 사용할 수 없습니다.
- 레이블 이름 입력시 키보드의 ESC키를 누르면 취소됩니다.
- 레이블 이름 입력시 키보드의 ENTER키를 누르면 입력이 완료됩니다.
- 점프의 레이블 이름 선택시 키보드의 ESC키를 누르면 취소됩니다.
- 점프의 레이블 이름 선택시 목록을 선택하거나 키보드의 ENTER키를 누르면 입력이 완료됩니다.

  ![점프 레이블][jump_label]

- 점프는 반드시 존재하는 레이블을 선택해야 합니다.
- 점프는 반드시 함수 구간 내의 레이블만 선택해야 합니다.

  ![점프 레이블][jump_label_target]

#### 예제

프로그램을 시작하자마자 '실행분기'레이블로 점프하여 루틴2를 실행하게 됩니다.

![점프 예제][jump_example]

### [조건문](#조건문)
조건의 참, 거짓 결과에 따라 프로그램 흐름을 분기하는 명령입니다.
- **만약**: 조건절의 내용이 참이면 실행합니다. C언어에서 if 구문과 같은 개념입니다.
- **아니면 만약**: '만약'에 이어서 조건을 계속 검사할 때 사용합니다. 조건절의 내용이 참이면 실행합니다. C언어의 else if 구문과 같은 개념입니다.
- **아니면**: '만약'과 '아니면 만약'의 조건 어디에도 해당되지 않으면 실행합니다. C언어의 else 구문과 같은 개념입니다.

#### 조건절이란?

조건절은 결과를 참과 거짓으로 내는 수식입니다. 참은 조건이 만족된 것이고, 거짓은 조건이 만족되지 못한것입니다.
조건절은 다음과 같이 3부분으로 구성되고, 차례대로 비교 파라미터1, 비교 연산자, 비교 파라미터2입니다.

비교 연산자의 종류는 다음과 같습니다.

- == : 두 비교 값이 같다면 참입니다.
- != : 두 비교 값이 다르다면 참입니다.
- &gt;= : 비교 값1이 비교 값2보다 크거나 같다면 참입니다.
- &gt; : 비교 값1이 비교 값2보다 크다면 참입니다.
- <= : 비교 값1이 비교 값2보다 작거나 같다면 참입니다.
- < : 비교 값1이 비교 값2보다 작다면 참입니다.

조건절은 연결 연산자에 의해 연결되어 복합 조건절로 사용할 수 있습니다.  
복합 조건절은 다음과 같이 3부분으로 구성되고, 차례대로 조건절1, 연결 연산자, 조건절2입니다.  
연결 연산자의 종류는 다음과 같습니다.

- **then** : 아무 조건절도 연결하지 않습니다.
- **AND(\&\&)**: 두 조건절의 결과를 AND연산합니다.
- **OR(\|\|)**: 두 조건절의 결과를 OR연산합니다.

복합 조건절은 제한 없이 연결될 수 있으며 앞에서부터 차례대로 연산되어 최종 값은 참과 거짓으로 표현됩니다.

#### 사용법

- '아니면 만약'과 '아니면'은 반드시 먼저 '만약'이 나와야 합니다.
- 각 구문은 명령 묶음인 구간이 반드시 필요합니다. (단, 실행 문이 1줄일 경우에는 별도로 구간 표시를 하지않아도 자동으로 구간으로 인식합니다.)

#### 예제

다음 조건별로 실행시키고자 할 때 사용되는 예제입니다.
- 변수 값이 90보다 클 경우
- 변수 값이 80보다 크고 90보다 작을 경우
- 변수 값이 70보다 크고 80보다 작을 경우
- 변수 값이 60보다 크고 70보다 작을 경우
- 그 외의 경우

### [무조건 반복](#무조건-반복)
무조건 반복 명령 구간 시작과 끝 사이를 계속 반복 실행합니다.

#### 사용법

명령 묶음인 구간이 반드시 필요합니다. (단, 실행 문이 1줄일 경우에는 별도로 구간 표시를 하지않아도 자동으로 구간을 인식합니다.)



반복 구문을 빠져나오려면 반복 끝내기를 사용합니다.

#### 예제

프로그램 출력 화면에 10이라는 수를 계속 출력합니다.

### [조건 반복](#조건-반복)
조건절이 참인 동안 구간내의 명령줄을 반복합니다. C언어의 while구문과 같은 개념입니다.

#### 사용법

명령 묶음인 구간이 반드시 필요합니다. (단, 실행 문이 1줄일 경우에는 별도로 구간 표시를 하지않아도 자동으로 구간을 인식합니다.)

반복 구문을 강제로 빠져나오려면 반복 끝내기를 사용합니다.

#### 예제

프로그램 출력 화면에 변수 값이 30이 될 때까지 화면 출력을 반복합니다.

### [횟수 반복](#횟수-반복)

구간내의 명령줄을 횟수만큼 반복시킵니다. 시작 값과 끝 값을 설정하면 지정한 변수를 1씩 증가시키면서 반복합니다. 반복횟수는 다음의 식으로 알 수 있습니다.

```
반복횟수 = 끝값 - 시작값 + 1
```

C언어의 for구문과 같은 개념입니다.

#### 사용법

명령 수행에 필요한 3개의 파라미터(변수, 시작값, 끝값)를 적절히 선택합니다.

![횟수 반복_1][for_1]

시작값은 끝값보다 작아야 합니다. **만약, 시작값보다 끝값이 크다면 단 한번도 반복하지 않습니다.**
명령 묶음인 구간이 반드시 필요합니다. (단, 실행 문이 1줄일 경우에는 별도로 구간 표시를 하지않아도 자동으로 구간을 인식합니다.)

![횟수 반복_2][for_2]

반복 구문을 강제로 빠져나오려면 반복 끝내기를 사용합니다.

#### 예제

감지된 소리 횟수만큼 반복하는 예제입니다.

![횟수 반복 예제][for_example]

### [반복 끝내기](#반복-끝내기)

행 중인 반복을 무조건 종료하고 싶을 때 사용합니다.
C언어의 break구문과 같은 개념입니다.

![반복 끝내기][break]

#### 사용법

반드시 반복구문 안에 존재해야 합니다.

#### 예제

숫자 10을 계속 화면출력하다가, 중앙 적외선 센서값이 400보다 클 때 반복 끝내기를 실행하고 화면에 30을 출력합니다.

![반복 끝내기 예제][break_example]

### [조건 대기](#조건-대기)

조건절이 참인 동안 프로그램 수행을 멈춥니다.
C언어의 while 구문과 같은 개념입니다.

#### 사용법

명령 묶음인 구간이 필요 없이 적절한 조건을 설정합니다.

#### 예제

타이머가 완료될 때까지 기다리는 예제입니다.

![조건 대기][stand_example]

### [함수 강제종료](#함수-강제종료)

함수 내에서 함수 강제 종료 명령을 만나면, 실행 중인 함수를 즉시 종료하고, 함수를 호출한 곳으로 돌아갑니다.
C언어의 return과 같은 개념입니다.

![함수 강제종료][return]

#### 사용법

일반 함수와 콜백 함수 내부에서만 사용할 수 있습니다.

#### 예제

프로그램 시작 후 사용자 함수를 계속 실행합니다. 사용자 함수 내부에는 함수 강제 종료 명령(복귀)이 있어, 마지막 3줄을 실행하지 않고 함수를 종료합니다.

![함수 강제종료 예제][return_example]

### [함수 만들기/호출](#함수-만들기호출)

동일한 코드가 반복 되거나, 특정 코드 영역을 역할 단위로 구분하고자 하는 경우, 그 내용을 함수로 만들 수 있으며, 필요한 곳에서 호출하여 사용할 수 있습니다. C언어의 함수와 같은 개념입니다. 단, C언어의 함수와 달리 리턴값과 인자가 없습니다.
함수를 적절히 활용하면 프로그램의 흐름을 쉽게 파악할 수 있으며, 특히 반복적인 동작을 함수로 대체하면 프로그램 코드 사용량을 크게 줄일 수 있습니다.
만들어진 함수는 호출을 함으로써 실행할 수 있으며, 함수가 종료되면 호출한 위치로 다시 되돌아와서 프로그램을 계속 진행합니다.

![함수 만들기/호출][function_1]

#### 사용법

* 함수를 만들때 이름은 다음의 규칙을 지켜야 합니다.
  * 함수 이름은 중복될 수 없습니다.
  * 함수는 다른 함수, 혹은 프로그램 구문 안에 만들어질 수 없으며, 가장 바깥쪽에 만들어 합니다.
  * 함수의 이름은 띄어쓰기와 특수 기호(!, @, #, $등)를 사용할 수 없습니다.
* 함수의 이름은 첫 글자로 숫자를 사용할 수 없습니다.
* 함수 이름 입력시 키보드의 ESC키를 누르면 취소됩니다.
* 함수 이름 입력시 키보드의 ENTER키를 누르면 입력이 완료됩니다.
* 호출할 함수 선택시 키보드의 ESC키를 누르면 취소됩니다.
* 호출할 함수 선택시 목록을 선택하거나 키보드의 ENTER키를 누르면 입력이 완료됩니다.

  ![함수 만들기/호출 사용법][function_2]

함수 내에서 자기 자신을 호출할 수 없습니다.

  ![함수 만들기/호출 사용법][function_3]

#### 예제

프로그램을 시작한 후 전진, 후진, 우회전하기, 좌회전하기 함수를 계속 실행합니다.

![함수 만들기/호출 사용법][function_example]

### [콜백 함수](#콜백-함수)

콜백(Callback) 함수는 일반 함수 및 메인 프로그램 루틴과 독립적으로 동작하는 함수이며, 일정한 시간마다 스스로 실행됩니다. 따라서 과도한 실행 시간을 요하는 코드를 넣을 수 없으며, 이를 위해 반복문 사용, 변수 사용량, 파라미터 호출 횟수, 코드 용량 등에 제한을 두고 있습니다.

#### 사용법

* 콜백 함수는 다른 함수, 혹은 프로그램 구문 안에 만들어질 수 없으며, 가장 바깥쪽에 만들어 합니다.
* 콜백 함수는 오직 1개만 존재할 수 있습니다.
* 콜백 함수는 이름이 없으며, 호출되지 않습니다.

#### 제한 사항

* 무조건 반복, 조건 반복, 횟수 반복, 레이블, 점프, 함수 호출 등의 명령어를 사용 할 수 없습니다.
* 다이나믹셀과 같은 외부장치와의 통신 횟수에 제약이 있습니다. ( 2회를 넘을 수 없습니다.)
* 코드 크기에 제약이 있습니다. (최대 512byte)

#### 예제

콜백 함수에서 주기적으로 받은 무선 데이터를 변수에 저장하는 예제입니다

![콜백함수 예제][callback_example]


[ctrl-select]: /assets/images/sw/rplus1/task/roboplus_task_022.png
[sft-select]: /assets/images/sw/rplus1/task/roboplus_task_023.png
[select-all]: /assets/images/sw/rplus1/task/roboplus_task_024.png
[insert-line]: /assets/images/sw/rplus1/task/roboplus_task_025.png
[delete_backspace]: /assets/images/sw/rplus1/task/roboplus_task_026.png
[delete_delete]: /assets/images/sw/rplus1/task/roboplus_task_027.png
[activate]: /assets/images/sw/rplus1/task/roboplus_task_028.png
[cut]: /assets/images/sw/rplus1/task/roboplus_task_029.png
[copy]: /assets/images/sw/rplus1/task/roboplus_task_030.png
[paste]: /assets/images/sw/rplus1/task/roboplus_task_031.png
[search_name]: /assets/images/sw/rplus1/task/roboplus_task_032.png
[search_next]: /assets/images/sw/rplus1/task/roboplus_task_033.png
[main]: /assets/images/sw/rplus1/task/roboplus_task_034.png
[end01]: /assets/images/sw/rplus1/task/roboplus_task_035.png
[end02]: /assets/images/sw/rplus1/task/roboplus_task_036.png
[end_example]: /assets/images/sw/rplus1/task/roboplus_task_037.png
[section]: /assets/images/sw/rplus1/task/roboplus_task_038.png
[omitted]: /assets/images/sw/rplus1/task/roboplus_task_039.png
[section_example]: /assets/images/sw/rplus1/task/roboplus_task_040.png
[comment]: /assets/images/sw/rplus1/task/roboplus_task_041.png
[math]: /assets/images/sw/rplus1/task/roboplus_task_042.png
[select_operator]: /assets/images/sw/rplus1/task/roboplus_task_043.png
[select_parameter]: /assets/images/sw/rplus1/task/roboplus_task_044.png
[math_example]: /assets/images/sw/rplus1/task/roboplus_task_045.png
[load]: /assets/images/sw/rplus1/task/roboplus_task_046.png
[select_load]: /assets/images/sw/rplus1/task/roboplus_task_047.png
[load_example01]: /assets/images/sw/rplus1/task/roboplus_task_048.png
[load_example02]: /assets/images/sw/rplus1/task/roboplus_task_049.png
[label_jump]: /assets/images/sw/rplus1/task/roboplus_task_050.png
[jump_label]: /assets/images/sw/rplus1/task/roboplus_task_051.png
[jump_label_target]: /assets/images/sw/rplus1/task/roboplus_task_052.png
[jump_example]: /assets/images/sw/rplus1/task/roboplus_task_053.png
[if_condition]: /assets/images/sw/rplus1/task/roboplus_task_054.png
[compare_operator]: /assets/images/sw/rplus1/task/roboplus_task_055.png
[complex_operator]: /assets/images/sw/rplus1/task/roboplus_task_056.png
[connect_operator_type]: /assets/images/sw/rplus1/task/roboplus_task_057.png
[if]: /assets/images/sw/rplus1/task/roboplus_task_058.png
[if_example]: /assets/images/sw/rplus1/task/roboplus_task_059.png
[while]: /assets/images/sw/rplus1/task/roboplus_task_060.png
[while_example]: /assets/images/sw/rplus1/task/roboplus_task_061.png
[while_if]: /assets/images/sw/rplus1/task/roboplus_task_062.png
[while_if_example]: /assets/images/sw/rplus1/task/roboplus_task_063.png
[for_1]: /assets/images/sw/rplus1/task/roboplus_task_064.png
[for_2]: /assets/images/sw/rplus1/task/roboplus_task_065.png
[for_example]: /assets/images/sw/rplus1/task/roboplus_task_066.png
[break]: /assets/images/sw/rplus1/task/roboplus_task_068.png
[break_example]: /assets/images/sw/rplus1/task/roboplus_task_069.png
[stand_example]: /assets/images/sw/rplus1/task/roboplus_task_070.png
[return]: /assets/images/sw/rplus1/task/roboplus_task_071.png
[return_example]: /assets/images/sw/rplus1/task/roboplus_task_072.png
[function_1]: /assets/images/sw/rplus1/task/roboplus_task_073.png
[function_2]: /assets/images/sw/rplus1/task/roboplus_task_074.png
[function_3]: /assets/images/sw/rplus1/task/roboplus_task_075.png
[function_example]: /assets/images/sw/rplus1/task/roboplus_task_076.png
[callback_example]: /assets/images/sw/rplus1/task/roboplus_task_077.png
